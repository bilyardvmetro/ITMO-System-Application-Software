stack

доступные хранилища памяти:
- регистры: A, B
- стек:
T -- верхушка стека данных
S -- второе значение на стеке данных
R -- вершнина стека возвратов

stack -- весь стек данных
rstack -- весь стек возвратов

EAM -- расширенный ариф режим. Прибавляет числа вместе с кэри флагом (с учетом переноса)

C -- кэри флаг

ЗАГРУЗКА
==========
lit <value> - dataStack.push(<value>)
@p <address> - dataStack.push(mem[<address>]). Кладем на стек значение с адреса

@ - dataStack.push(mem[A]). Кладем на стек значение с адреса из регистра A
@+ - то же, что и выше, только с инкрементом еще

@b - то же, что и для A, только для b

a - dataStack.push(A)

СОХРАНЕНИЕ
===========
!p <address> - mem[<address>] <- dataStack.pop()

! - mem[A] <- dataStack.pop(). Кладем верхушку стека в память по адресу из регистра A
!+ - mem[A] <- dataStack.pop(); A <- A + 1. Сохранение с автоинкрементом адреса в A

!b - mem[B] <- dataStack.pop()

a! - A <- dataStack.pop(). Кладем со стека в регистр A
b! - B <- dataStack.pop()

АРИФМЕТИКА
============
умножение и деление это пиздец какой-то, но они мне и не нужны

eam - достаем значение с верхушки стека (непонятно куда) и врубаем eam флаг
+ - складываем первое и второе число с вершины стека и кладем результат на вершину вместо старого значения там. При включенном eam, сложим с переносом

БИТОВЫЕ ОПЕРАЦИИ
===================
and и xor двух первых чисел с вершины стека. ну кароче как сложение в плане операндов и сохранения

РАБОТА СО СТЕКОМ
===================
drop - удалить значение с верхушки стека
dup - дублировать значение с текущей верхушки на стек
over - свапнуть местами верхушку и второй элемент на стеке

КАНТРОЛ ФЛОУ
====================
; - ретернуться из функции. pc <- returnStack.pop()
<label> - call по метке. returnStack.push(p); pc <- label

next <label> - цикл по метке. В качестве счетчика используется вершина стека возвратов. Положить его туда можно при помощи >r. while R != 0 {R <- R - 1; pc <- <label>}

<label> ; - джамп на метку. pc <- label
if <label> - прыгнуть на метку, если вершина стека = 0
-if <label> - прыгнуть на метку, если вершина стека >= 0

halt

РЕГИСТРЫ
===========
r> - dataStack.push(returnStack.pop()). Мувнуть верхушку ретернстека на верхушку датастека
>r - returnStack.push(dataStack.pop()). Мувнуть верхушку датастека на верхушку ретернстека








