.data
	input_addr: .word 0x80
	output_addr: .word 0x84
	

.text
_start:
	@p input_addr
	b!
	@b

	sum
	
	@p output_addr
	b!
	!b
	halt
	

sum:
	a					\ сохраняем исходное значение a,
	over				\ тк на выходе из подпрограммы его нужно вернуть
						\ в прежнее состояние
	dup
	if return_error		\ если число = 0, выходим с ошибкой
	dup
	-if calc			\ если число > 0, переходим к расчету
	return_error ;		\ если число < 0, выходим с ошибкой
	
	
calc:					\ ((1 + n) / 2) * n = 1/2 * (n + n*n) - сумма ариф прогрессии
	dup
	a!					\ это будет множимое и оно должно лежать в a
	lit 0				\ на верх стека будут класться верхние 32 бита результата
	
	lit 31				\ 31 в счетчик, тк умножить нужно число, а умножаем побитово.
	>r
	
multiply:
	+*					\ умножаем число на само себя
	next multiply
	
	dup
	if success
	
overflow:
	drop				\ вернули регистр a в прежнее состояние
	a!
	
	lit 0xCCCCCCCC		\ ошибка переполнения
	;

success:
	drop				\ убираем мусорную часть с верха стека
	a					\ загружаем на стек результат из a
	+					\ прибавляем исходное число 
	2/					\ делим все на 2
	
	over				\ вернули регистр a в прежнее состояние
	a!
	;					\ вышли
	
return_error:
	drop				\ вернули регистр a в прежнее состояние
	a!
	
	lit -1
	;					\ вышли
