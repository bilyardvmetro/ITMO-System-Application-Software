risc

view:
<reg>:[dec | hex]	вывести че лежит в регистре

Регистры:
Zero, Ra, Sp, Gp, Tp, S0Fp,
A0, A1, A2, A3, A4, A5, A6, A7, 
S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, 
T0, T1, T2, T3, T4, T5, T6

%hi(адрес | значение) - взять верхние 20 бит из адреса/значения
%lo(адрес | значение) - взять нижние 12 бит из адреса/значения

каждая инструкция 4 байта

1110 0101 1100 0011 1010 0000 0000 0000 

lui <r> <k> 			загружает k, в верхнюю часть регистра (первые 20 бит)
типа вот так:
1110 0101 1100 0011 1010 0000 0000 0000 
e    5    c    3    a    0    0    0

sw <r1>, <offset>(<r2>)		сохраняет в память 32 бита r1 по адресу = смещение + адрес из r2
можно сохранить байт, но нельзя загрузить байт

addi <rd>, <rs>, <k>		rd <- rs + k, где k число 12 бит. Сохранение идет только в младшие 12 бит rd
mulh <rd>, <rs1>, <rs2>		rd <- верхние_20_бит(rs1 * rs2)

арифметический сдвиг только вправо
Циклический сдвиг перемещает поочередно старшие биты на места младших, а их переносит вперед. Операторы сдвига вправо >> и >>> сдвигают свой левый операнд вправо на количество битовых позиций, заданных правым операндом. Логический сдвиг вправо должен заполнить освободившиеся битовые позиции нулями.

jal <rd> <k>			rd <- pc + 4  байта, pc <- pc + k. Используем rd, типа как стек. кладем в него адрес, куда мы должны вернуться на выходе из подпрограммы, а в счетчик команд кладем pc + k, где  k - это смещение
j <k>				pc <- pc + k. Прыгнуть на k байт вперед
jr <rs>				pc <- rs. Прыгнуть на адрес из rs

beqz <rs> <k>			Прыгнуть на k байт вперед, если rs == 0
bnez <rs> <k>			Прыгнуть на k байт вперед, если rs != 0

bgt <rs1> <rs2> <k>		Прыгнуть на k байт вперед, если rs1 > rs2
ble <rs1>, <rs2>, <k>		Прыгнуть на k байт вперед, если rs1 <= rs2
Их аналоги, только для беззнаковых чисел
bgtu <rs1>, <rs2>, <k>
bleu <rs1>, <rs2>, <k>

beq <rs1>, <rs2>, <k>		Прыгнуть на k байт вперед, если rs1 == rs2
bne <rs1>, <rs2>, <k>		Прыгнуть на k байт вперед, если rs1 != rs2
